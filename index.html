<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='utf-8'>
    <meta content='width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0' name='viewport'>

    <title>Music Visualization</title>
    <link href='scripts/bootstrap-3.3.6-dist/css/bootstrap.css' rel='stylesheet' type='text/css'>
    <link href='scripts/dc.js/dc.css' rel='stylesheet' type='text/css'>
    <!-- <link href='scripts/d3/lib/colorbrewer/colorbrewer.css' rel='stylesheet' type='text/css'> -->
    <link href="scripts/jquery-ui-1.11.4.custom/jquery-ui.css" rel="stylesheet" type="text/css">
    <link href="scripts/Guriddo_jqGrid_JS_5/css/ui.jqgrid.css" rel="stylesheet" type="text/css">

    <script src='scripts/d3/d3.js' type='text/javascript'></script>
    <script src='scripts/jquery-2.2.3.js' type='text/javascript'></script>
    <script src='scripts/bootstrap-3.3.6-dist/js/bootstrap.min.js' type='text/javascript'></script>

    <!-- <script src='scripts/d3/lib/colorbrewer/colorbrewer.js' type='text/javascript'></script> -->
    <script src='scripts/jquery-ui-1.11.4.custom/jquery-ui.js' type='text/javascript'></script>
    <script src='scripts/Guriddo_jqGrid_JS_5/js/i18n/grid.locale-en.js' type='text/javascript'></script>
    <script src='scripts/Guriddo_jqGrid_JS_5/js/jquery.jqGrid.min.js' type='text/javascript'></script>
    <style type="text/css">
        body {
            font: 10px sans-serif;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        .x.axis path {
            display: inline;
            stroke-width:3px;
        }

        .y.axis path{
          display:none;
        }


       .line {
            fill: none;
        }

        .user:nth-child(3) .line{
          stroke: #F98229;
          stroke-width: 3px;
        }
        .user:nth-child(4) .line{
          stroke: #4AC2BC;
          stroke-width: 3px;
        }

        svg,.container{
        font: 12px 'Inconsolata',Monaco,"Lucida Console",Consolas,"Courier New";
        }

        .tick line{
          opacity: 0.1;
          stroke-width:1px;
        }

        .button1 {
          margin-left: auto;
          margin-right: auto;
        }

        #hourButton.active{
          color: white;
          background-color:black;
        }
        #weekButton.active{
          color:white;
          background-color:black;
        }
        .line-graph{
          margin-left: auto;
          margin-right: auto;
        }
        .col-centered{
          float:none;
          margin: 0 auto;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-default">
     <div class="container-fluid">
       <!-- Brand and toggle get grouped for better mobile display -->

       <!-- Collect the nav links, forms, and other content for toggling -->
       <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1" style="font-size:14px;">
         <ul class="nav navbar-nav">
           <li class="active"><a href="#">Listening behavior: Time <span class="sr-only">(current)</span></a></li>
           <li><a href="/music_vis_line.html">Listening behavior: song attribute</a></li>
           <li><a href="/barchart.html">Device & Traffic source</a></li>
           <li><a href="/treemap.html">Listening preference</a></li>
         </ul>
       </div><!-- /.navbar-collapse -->
     </div><!-- /.container-fluid -->
    </nav>


    <div class='container' id='main-container'>
        <div class='content'>
            <div class='container'>
                <div class='row'>
                   <div class="col-sm-8 col-md-8 col-lg-8 col-centered">
                    <h3 style="margin-top:50px">Daily/Weekly Listening Behavior #1: Time</h3>
                   </div>
                </div>
                <div class='row'>
                   <div style="font-size:14px;" class="col-sm-8 col-md-8 col-lg-8 col-centered">
                     <p>User1 spend the most time listening at 4pm, while user2's ear is busiest at 8pm. </p>
                     <p>Both of them are not listening actively on Saturday.<p>
                   </div>
                </div>
                <div style="margin-top:40px;" class='row'>
                    <div class="button1 input-group col-sm-1 col-md-1 col-lg-1">
                        <div class="input-group-btn">
                            <button id="hourButton" style = "border-color: grey;" type="button" class="btn active btn-default">by hours</button>
                            <button id="weekButton" style = "border-color: grey;" type="button" class="btn btn-default">by days</button>
                        </div>
                    </div>
                </div>
                <div class='row'>
                    <div class='line-graph col-sm-10 col-md-10 col-lg-10 col-centered' id='line-chart'></div>
                </div>
            </div>
        </div>

    </div>

    <script>
              //margin for the charts
              var margin = {
                      top: 20,
                      right: 80,
                      bottom: 30,
                      left: 100
                  },
                  //use "div" width as chart width, adjusted for margins
                  width = $("#line-chart-total").width() - margin.left - margin.right,
  				//height is half the width
                  height = width /
                  2 - margin.top - margin.bottom;


              //utility function to check for leap year
              var isLeapYear = function(d) {
                  var year = d.getFullYear();
                  if ((year & 3) != 0) return false;
                  return ((year % 100) != 0 || (year % 400) == 0);
              };

              // Get Day of Year
              var getDOY = function(d) {
                  var dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
                  var mn = d.getMonth();
                  var dn = d.getDate();
                  var dayOfYear = dayCount[mn] + dn;
                  if (mn > 1 && isLeapYear(d)) dayOfYear++;
                  return dayOfYear;
              };

              //get the week number
              function getWeekOfYear(d) {
                  var wd = new Date(d);
                  wd.setHours(0, 0, 0);
                  wd.setDate(wd.getDate() + 4 - (wd.getDay() || 7));
                  if (d.getDay() == wd.getDay()) return +Math.ceil((((d - new Date(d.getFullYear(), 0, 1)) / 8.64e7) + 1) / 7);
                  else return 0;
              }

              var weekFormat = d3.time.format("%w");
              var weekStringFormat = d3.time.format("%a");

              var hourBoundaryData = {};

              //modify the data records from csv,
              //add hour of day (derived from song start timestamp)
              //add week of year
              //adjust for songs played across hour boundaries

              function fixData(user, d) {
                  var ot = d.timestamp;
                  d.user = user;
                  d.timestamp = parseDate(d.timestamp);
                  if (!d.timestamp) {
                      console.error("Invalid timestamp data " + ot);
                      return;
                  }
                  if (isNaN(d.milliseconds_played)) {
                      console.log("Invalid time played " + d.milliseconds_played);
                      return;
                  }
                  d.hour = d.timestamp.getHours();

                  d.weekDay = weekFormat(d.timestamp);
                  //adjust to make Monday start of the week
                  if (d.weekDay == 0) d.weekDay = 6;
                  else d.weekDay -= 1;
                  d.dayOfYear = getDOY(d.timestamp);
                  d.weekOfYear = getWeekOfYear(d.timestamp);

                  //adjust for hour boundaries
                  //song started at 10:59 and played for 5min, will be adjusted as
                  //2 songs, one in 10-11 slot, and played for a min
                  //the second in 11-12 slot, and played for 4 min
                  //this calculation does not usually make much difference (for big data sets),
                  //since things get averaged out over a long period of time
                  var nt = new Date(d.timestamp.getTime() + (+d.milliseconds_played));
                  if (nt.getHours() != d.hour) {
                      var hb = new Date(nt.getTime());
                      hb.setHours(nt.getHours());
                      hb.setMinutes(0);
                      hb.setSeconds(0);
                      hb.setMilliseconds(0);
                      var m1 = hb.getTime() - d.timestamp.getTime();
                      var m2 = (+d.milliseconds_played) - m1;
                      d.milliseconds_played = m1;

                      var d2 = $.extend(true, {}, d);
                      d2.timestamp = hb;
                      d2.hour = d2.timestamp.getHours();

                      d2.weekDay = weekFormat(d2.timestamp);
                      //adjust to make Monday start of the week
                      if (d2.weekDay == 0) d2.weekDay = 6;
                      else d2.weekDay -= 1;
                      d2.dayOfYear = getDOY(d2.timestamp);
                      d2.weekOfYear = getWeekOfYear(d2.timestamp);
                      if(!hourBoundaryData[user]) {
                      	hourBoundaryData[user]=[];
                      }
                      hourBoundaryData[user].push(d2);
                  }

              }

              //format of timestamp field in csv file
              var parseDate = d3.time.format("%Y/%m/%d %H:%M:%S").parse;

              //scale for x-axis, metric and total time charts
              var x = d3.time.scale().range([0, width]);
              var xTotal = d3.time.scale().range([0, width]);

              //scale for y-axis, metric and total time charts
              var y = d3.scale.linear().range([height, 0]);
              var yTotal = d3.scale.linear().range([height, 0]);

              //10 color values for the lines
              var color = d3.scale.category10();

              //put all hours into an array to use as x-axis tick values
              var hourTickValues = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
                  12, 13, 14, 15, 16, 17, 18, 19, 20,
                  21, 22, 23, 24
              ];

              //the hour time axis, add text to distinguish 12 midnight, and 12 noon
              function hourTickFormat(v) {
                  var s = "";
                  if (v == 0) s = "12AM";
                  else if (v == 12) s = "12 Noon";
                  else if (v > 12) s = (v - 12) + "";
                  else s = v;
                  return s;
              }

              //various metrics that need to be displayed in the line charts
              var metrics = {
                  "hour": [{
                      name: "averageValenceScore",
                      ylabel: "Average Valence Score"
                  }, {
                      name: "averageDanceabilityScore",
                      ylabel: "Average Danceability"
                  }, {
                      name: "averageFamiliarityScore",
                      ylabel: "Average Familiarity"
                  }, {
                      name: "averageRunnability",
                      ylabel: "Average Runnability"
                  }, {
                      name: "averageEnergy",
                      ylabel: "Average Energy"
                  }, {
                      name: "averagePopularityNormalized",
                      ylabel: "Average Popularity"
                  }],
                  "week": [{
                      name: "averageValenceScore",
                      ylabel: "Average Valence Score"
                  }, {
                      name: "averageDanceabilityScore",
                      ylabel: "Average Danceability"
                  }, {
                      name: "averageFamiliarityScore",
                      ylabel: "Average Familiarity"
                  }, {
                      name: "averageRunnability",
                      ylabel: "Average Runnability"
                  }, {
                      name: "averageEnergy",
                      ylabel: "Average Energy"
                  }, {
                      name: "averagePopularityNormalized",
                      ylabel: "Average Popularity"
                  }]
              };

              //assign domain for hour and week
              //for hour we use 24, the value at 0 is used as value at hour 24
              var xDomainMap = {
                  "hour": [0, 24],
                  "week": [0, 6]
              };

              //all the metrics used have a range of 0-1
              var yDomain = [0, 1];

              var weekTickValues = [0, 1, 2, 3, 4, 5, 6];
              var weekTickStringValues = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
              //convert day of week value [0-6] to Mon to Sun
              function weekTickFormat(v) {
                  var s = weekTickStringValues[+v];
                  return s;
              }
              var showChartForMetric = null;

              //select firt chart from the list of metrics charts
              var selectedIndex = 0;

              //default xaxis type
              var xAxisType = "hour";
              var xAxisTypeTotal = "hour";

              //cycle through the metrics charts when previous or next button is clicked
              $("#prevButton").on("click", function(evt) {
                  selectedIndex--;
                  if (selectedIndex < 0) selectedIndex = metrics[xAxisType].length - 1;
                  else if (selectedIndex >= metrics[xAxisType].length) selectedIndex = 0;
                  if (metrics[xAxisType][selectedIndex]) showChartForMetric(metrics[xAxisType][selectedIndex]["name"], xAxisType);
              });

              $("#nextButton").on("click", function(evt) {

                  selectedIndex++;
                  if (selectedIndex < 0) selectedIndex = metrics[xAxisType].length - 1;
                  else if (selectedIndex >= metrics[xAxisType].length) selectedIndex = 0;
                  if (metrics[xAxisType][selectedIndex]) showChartForMetric(metrics[xAxisType][selectedIndex]["name"], xAxisType);

              });

              //show metric when one of the metric button is clicked
              $(document).on('change', 'input:radio[id^="metric_"]', function(event) {
                  selectedIndex = $(event.target)[0].value;
                  if (metrics[xAxisType][selectedIndex]) showChartForMetric(metrics[xAxisType][selectedIndex]["name"], xAxisType);

              });

              //handle switch between hour and week charts
              $("#hourButton").on("click", function(evt) {
                  $("#hourButton").addClass("active");
                  $("#weekButton").removeClass("active");
                  xAxisType = "hour";
                  if (metrics[xAxisType][selectedIndex]) showChartForMetric(metrics[xAxisType][selectedIndex]["name"], "hour");
              });
              $("#weekButton").on("click", function(evt) {
                  $("#weekButton").addClass("active");
                  $("#hourButton").removeClass("active");
                  xAxisType = "week";
                  if (metrics[xAxisType][selectedIndex]) showChartForMetric(metrics[xAxisType][selectedIndex]["name"], "week");

              });

              //handle switch between hour and week charts for total time chart
              $("#hourButtonTotal").on("click", function(evt) {
                  $("#hourButtonTotal").addClass("active");
                  $("#weekButtonTotal").removeClass("active");
                  xAxisTypeTotal = "hour";
                  showChartForMetric("totalMilliseconds", "hour", true);
              });
              $("#weekButtonTotal").on("click", function(evt) {
                  $("#weekButtonTotal").addClass("active");
                  $("#hourButtonTotal").removeClass("active");
                  xAxisTypeTotal = "week";
                  showChartForMetric("totalMilliseconds", "week", true);

              });


              //place x axis at bottom,
              //using scale x defined above
              //and format tick text to show 12AM, 12 noon (see hourTickFormat function above)
              var xAxis = d3.svg.axis().scale(x).orient("bottom")
                  .tickValues(hourTickValues)
                  .tickFormat(hourTickFormat);
              var xAxisTotal = d3.svg.axis().scale(xTotal).orient("bottom")
                  .tickValues(hourTickValues)
                  .tickFormat(hourTickFormat);
              //place y axis on the left, using scale y
              var yAxis = d3.svg.axis().scale(y).orient("left");
              var yAxisTotal = d3.svg.axis().scale(yTotal).tickFormat(d3.format(formatAsDate)).orient("left");

              //the following "line" is used for all the metrics,  depending on the chart chosen
              //the value function will be changed
              var line = d3.svg.line().interpolate("basis").x(function(d) {
                  return x(+d[xAxisType]);
              }).y(function(d) {
                  return y(+d.totalMilliseconds);
              });
              var lineTotal = d3.svg.line().interpolate("basis").x(function(d) {
                  return xTotal(+d[xAxisType]);
              }).y(function(d) {
                  return yTotal(+d.totalMilliseconds);
              });

              //create a chart with specified width, height at the corresponding div
              var vis = d3.select("#line-chart-metrics").append("svg").attr("width",
                  width + margin.left + margin.right).attr("height",
                  height + margin.top + margin.bottom);

              var visTotal = d3.select("#line-chart-total").append("svg").attr("width",
                  width + margin.left + margin.right).attr("height",
                  height + margin.top + margin.bottom);

              //create a rectangle element to cover the entire chart
              //when this invisible rectangle is dragged, we handle the event to switch charts
              //*not used*
              var rect = vis.append("rect").attr("width", width)
                  .attr("height", height)
                  .attr("fill", "none")
                  .style("pointer-events", "all");


              var svg = vis.append("g").attr(
                  "transform",
                  "translate(" + margin.left + "," + margin.top + ")");

              var svgTotal = visTotal.append("g").attr(
                  "transform",
                  "translate(" + margin.left + "," + margin.top + ")");


              var groupsMap = {};

              d3.csv("data/User1.csv", function(error, user1Data) {
                  if (error)
                      throw error;
                  d3.csv("data/User2.csv", function(error, user2Data) {
                      if (error)
                          throw error;
                      var data = []; //consolidated user data


                      //fix and join the user data into one array
                      //add extra records for songs that cross hour boundaries
                      user1Data.forEach(fixData.bind(undefined, "User1"));
                      user2Data.forEach(fixData.bind(undefined, "User2"));

                      user1Data = user1Data.concat(hourBoundaryData["User1"]);
                      user2Data = user2Data.concat(hourBoundaryData["User2"]);

                      var data = user1Data.concat(user2Data);
                      //used to get number of days (end date - start date) in the data set
                      //this number is used for averaging
                      var dayExtent = d3.extent(data, function(d) {
                          return d.dayOfYear;
                      });

                      //number of weeks in the data set

                      var weekExtent = d3.extent(data, function(d) {
                          return d.weekOfYear;
                      });


                      //Calculation of average energy for 2 songs is like this
                      //song 1 energy 0.2, played for 1000ms,  song 2, energy 0.8, played for 1000ms
                      //average energy is (0.2*1000 + 0.8*100)/1100 is 0.2545
                      //if we average by song, then it will be (0.2+0.8)/2 = 0.5
                      //we use averaging by milliseconds played



                      //this function gets data summary for specfied x dimension (hour or week)
                      //sorts it by hour or day of week, adds zeros for missing time slots
                      //sorting by x values is needed to plot the line charts
                      function getSummaryDataForUser(userData, xdim) {

                      	var rollupFn = function(v) {
                          	return {
                          		totalMilliseconds: d3.sum(v, function(d) {
                          			return d.milliseconds_played;
                          		}),
                          		totalValenceScore: d3.sum(v, function(d) {
                          			return d.valence_score ?
                          					d.valence_score*d.milliseconds_played : 0;
                          		}),
                          		totalDanceabilityScore: d3.sum(v, function(d) {
                          			return d.danceability_score ?
                          					d.danceability_score*d.milliseconds_played : 0;
                          		}),
                          		totalFamiliarityScore: d3.sum(v, function(d) {
                          			return d.familiarity_score? d.familiarity_score*d.milliseconds_played :0;
                          		}),
                          		totalSongTempo: d3.sum(v, function(d) {
                          			return d.song_tempo?d.song_tempo*d.milliseconds_played : 0;
                          		}),
                          		totalRunnability: d3.sum(v, function(d) {
                          			return d.runnability?d.runnability*d.milliseconds_played : 0;
                          		}),
                          		totalEnergy: d3.sum(v, function(d) {
                          			return d.energy?d.energy*d.milliseconds_played:0;
                          		}),
                          		totalPopularityNormalized: d3.sum(v, function(d) {
                          			return d.popularity_normalized?d.popularity_normalized*d.milliseconds_played : 0;
                          		})
                          	}
                          };

                        //group to get totals, counts for each hour slot
                          var hourData = d3.nest()
                              .key(function(d){return d.hour;})
                              .rollup(rollupFn)
                              .map(userData);
                          hourData = d3.entries(hourData).map(function(d) {
                          	var v = d.value;
                          	v["hour"] = d.key;
                          	v["key"] =  d.key;
                          	return v;
                          });

                        //group to get totals, counts for each day of week slot
                          var weekData = d3.nest().key(function(d) {
                              return d.weekDay;
                          }).rollup(rollupFn).map(userData);
                          weekData = d3.entries(weekData).map(function(d) {
                          	var v = d.value;
                          	v["week"] = d.key;
                          	v["key"] =  d.key;
                          	return v;
                          });

                          groupsMap["hour"] = hourData;


                          groupsMap["week"] = weekData;


                          var groupData=groupsMap[xdim];

                          if (xdim == "hour" || xdim == "week") {
                          	//if any hour slot or day of week, has no data in the csv data set
                          	//then put zero counts, totals for that hour/day of week
                              var missing = [];
                              var l = 24;
                              if (xdim == "week") l = 6;
                              var zeroData = {};
                              for (var i = 0; i <= l; i++) {
                                  var found = false;
                                  groupData.forEach(function(d) {
                                      if (d[xdim] == i) {
                                          found = true;
                                          //console.log("found "+d[xdim]);
                                      }
                                      if (d[xdim] == 0) zeroData = d;
                                  });
                                  if (!found && i != 24) missing.push(i);

                              }
                              missing.forEach(function(d) {
                                  var zdv = {

                                          totalMilliseconds: 0,
                                          totalValenceScore: 0,
                                          totalDanceabilityScore: 0,
                                          totalFamiliarityScore: 0,
                                          totalSongTempo: 0,
                                          totalRunnability: 0,
                                          totalEnergy: 0,
                                          totalPopularityNormalized: 0,
                                          totalValenceScoreSong: 0,
                                          totalDanceabilityScoreSong: 0,
                                          totalFamiliarityScoreSong: 0,
                                          totalSongTempoSong: 0,
                                          totalRunnabilitySong: 0,
                                          totalEnergySong: 0,
                                          totalPopularityNormalizedSong: 0
                                  };
                                  zdv[xdim]=d;
                                  zdv["key"]=d;
                                  groupData.push(zdv);
                              });
                              if (xdim == "hour") {
                                  //use value at hour 0, as value at hour 24

                                  var gzd = zeroData[xdim] ? $.extend({},zeroData) : {
                                          totalMilliseconds: 0,
                                          totalValenceScore: 0,
                                          totalDanceabilityScore: 0,
                                          totalFamiliarityScore: 0,
                                          totalSongTempo: 0,
                                          totalRunnability: 0,
                                          totalEnergy: 0,
                                          totalPopularityNormalized: 0,
                                          totalValenceScoreSong: 0,
                                          totalDanceabilityScoreSong: 0,
                                          totalFamiliarityScoreSong: 0,
                                          totalSongTempoSong: 0,
                                          totalRunnabilitySong: 0,
                                          totalEnergySong: 0,
                                          totalPopularityNormalizedSong: 0
                                      };
                                  gzd["hour"]=24;
                                  gzd["key"]=24;
                                  groupData.push(gzd);
                              }
                          }

                          //line charts require data to be sorted by ascending x-axis values
                          return groupData.sort(sortByKeyAscending);
                      }

                      //simple comparison function for numbers, used to sort array
                      function sortByKeyAscending(a, b) {
                          // Dates will be cast to numbers automagically:
                          return +a.key - (+b.key);
                      }



  					//create x and y axes
                      var xAxisSvg = svg.append("g").attr("class", "x axis").attr("transform",
                          "translate(0," + height + ")").call(xAxis);

                      var yAxisSvg = svg.append("g").attr("class", "y axis").call(yAxis);

                      //add y axis label for metrics chart
                      var yAxisText = yAxisSvg.append("text")
                          .attr("transform", "rotate(-90)").attr("y", 6).attr("dy",
                              "-60px").style("text-anchor", "end").text(
                              metrics["hour"][0].ylabel);

                      //create x and y axes for total time played chart
                      var xAxisSvgTotal = svgTotal.append("g").attr("class", "x axis").attr("transform",
                          "translate(0," + height + ")").call(xAxisTotal);

                      var yAxisSvgTotal = svgTotal.append("g").attr("class", "y axis").call(yAxisTotal);

                      //add label for y-axis for total time played chart
                      var yAxisTextTotal = yAxisSvgTotal.append("text")
                          .attr("transform", "rotate(-90)").attr("y", 6).attr("dy",
                              "-60px").style("text-anchor", "end").text(
                              "Total Listening Time (milliseconds)");

                      //define line for User1, use empty data set, line will
                      //be updated with user1 data later
                      var line1Svg = svg.append("path");
                      line1Svg.datum([])
                          .attr("class", "line1")
                          .attr("d", line).style("stroke", function(d) {
                              return color("User1");
                          });

                      //define line for User1
                      var line2Svg = svg.append("path");
                      line2Svg.datum([])
                          .attr("class", "line2")
                          .attr("d", line).style("stroke", function(d) {
                              return color("User2");
                          });

                      //define lines for total time chart
                      var line1SvgTotal = svgTotal.append("path");
                      line1SvgTotal.datum([])
                          .attr("class", "line1").style("stroke", function(d) {
                              return color("User1");
                          })
                          .attr("d", lineTotal);

                      var line2SvgTotal = svgTotal.append("path");
                      line2SvgTotal.datum([])
                          .attr("class", "line2").style("stroke", function(d) {
                              return color("User2");
                          })
                          .attr("d", lineTotal);

                      //define text to be user to label the line
                      //this text ("User1", or "User2") is put near the endpoint of the line
                      var line1Text = svg.append("text")
                          .datum([])
                          .attr("class", "label")
                          .attr("transform", "translate(0,0)")
                          .attr("x", 3)
                          .attr("dy", ".35em")
                          .text("");
                      var line2Text = svg.append("text")
                          .datum([])
                          .attr("class", "label")
                          .attr("transform", "translate(0,0)")
                          .attr("x", 3)
                          .attr("dy", ".35em")
                          .text("");

                    //define text to be user to label the line for total time chart
                      var line1TextTotal = svgTotal.append("text")
                          .datum([])
                          .attr("class", "label")
                          .attr("transform", "translate(0,0)")
                          .attr("x", 3)
                          .attr("dy", ".35em")
                          .text("User1");
                      var line2TextTotal = svgTotal.append("text")
                          .datum([])
                          .attr("class", "label")
                          .attr("transform", "translate(0,0)")
                          .attr("x", 3)
                          .attr("dy", ".35em")
                          .text("User2");


                      var firstTime = true;

                      //this function is assigned to variable in global scope
                      showChartForMetric = function(metric, xdim) {
                          var isTotal = false;
                          if (metric == "totalMilliseconds") isTotal = true;
                          var xLocal, yLocal, xAxisLocal, yAxisLocal,
                              xAxisSvgLocal, yAxisSvgLocal, svgLocal, line1SvgLocal, line2SvgLocal,
                              line1TextLocal, line2TextLocal, yAxisTextLocal, lineLocal;
                          if (isTotal) {
                              svgLocal = svgTotal;
                              xLocal = xTotal;
                              yLocal = yTotal;
                              xAxisLocal = xAxisTotal;
                              xAxisSvgLocal = xAxisSvgTotal;
                              yAxisLocal = yAxisTotal;
                              yAxisSvgLocal = yAxisSvgTotal;
                              line1SvgLocal = line1SvgTotal;
                              line2SvgLocal = line2SvgTotal;
                              line1TextLocal = line1TextTotal;
                              line2TextLocal = line2TextTotal;
                              yAxisTextLocal = yAxisTextTotal;
                              lineLocal = lineTotal;
                          } else {
                              svgLocal = svg;
                              xLocal = x;
                              yLocal = y;
                              xAxisLocal = xAxis;
                              xAxisSvgLocal = xAxisSvg;
                              yAxisLocal = yAxisTotal;
                              yAxisSvgLocal = yAxisSvgTotal;

                              line1SvgLocal = line1Svg;
                              line2SvgLocal = line2Svg;
                              line1TextLocal = line1Text;
                              line2TextLocal = line2Text;
                              yAxisTextLocal = yAxisText;
                              lineLocal = line;

                          }



                          var u1Data = getSummaryDataForUser(user1Data, xdim);
                          var factor = 1;

                          //for averaging we need the total number of days
                          //or weeks in the dataset
                          if (xdim == "hour") {
                              factor = dayExtent[1] - dayExtent[0];
                          } else {
                              factor = weekExtent[1] - weekExtent[0];
                          }
                          var totalMetric = metric;
                          if (metric.match(/^average/)) {
                              totalMetric = "total" + metric.substring(7);
                          } else {
                              factor = 1;
                          }

                          //get data for User2
                          var u2Data = getSummaryDataForUser(user2Data, xdim);
                          users = [{
                              name: "User1",
                              values: u1Data
                          }, {
                              name: "User2",
                              values: u2Data
                          }];


                          //get all data for both users, used to scale the y-axis for total time chart

                          var group = groupsMap[xdim];
                          var fullData = u1Data.concat(u2Data);



                          if (!isTotal) {
                          	//get min and max values for the metric chosen
                              var metricExtent = d3.extent(fullData, function(d) {
                                  if (metric == "totalMilliseconds")
                                      return d[totalMetric];
                                  if (metric != "averageMilliseconds" && d.totalMilliseconds == 0) return 0;
                                  if (metric == "averageMilliseconds")
                                      return d[totalMetric] / factor;
                                  return d[totalMetric] / (d.totalMilliseconds);
                              });
                          	var metricMin = metricExtent[0];
                          	var metricMax = metricExtent[1];


                              	//use default domain [0,1], since all metrics fall
                              	//within this rangle for charts other than total time played chart
                                  yLocal.domain(yDomain);

                              	//chose x-axis domain based on whether it is a hour or week chart
                                  xLocal.domain(xDomainMap[xdim]);

                          	//use the data for the user to draw the line
                              lineLocal = d3.svg.line().interpolate("basis").x(function(d) {
                                  return xLocal(+d[xdim]);
                              }).y(function(d) {
                                  if (metric == "totalMilliseconds")
                                      return yLocal(+d["totalMilliseconds"]);
                                  if (d.totalMilliseconds == 0) return yLocal(0);
                                  if (metric == "averageMilliseconds")
                                      return yLocal(+d[totalMetric] / factor);
                                  return yLocal((+d[totalMetric] / (d.totalMilliseconds)));
                              });
                          } else {

                          	//this is a total time chart
                              var metricMin = d3.min(fullData, function(d) {
                                  return d[metric];
                              });
                              var metricMax = d3.max(fullData, function(d) {
                                  return d[metric];
                              });

                              //set the domain based on the range of total time played
                              yLocal.domain([0, metricMax * 1.3]);
                              xLocal.domain(xDomainMap[xdim]);

                              //use the data for user to draw the line
                              lineLocal = d3.svg.line().interpolate("basis").x(function(d) {
                                  return xLocal(+d[xdim]);
                              }).y(function(d) {
                                  return yLocal(+d[metric]);
                              });
                          }


                      	//set the x-axis tick values
                          if (xdim == "hour") {
                              xAxisLocal.tickValues(hourTickValues).tickFormat(hourTickFormat);
                          } else {
                              xAxisLocal.tickValues(weekTickValues).tickFormat(weekTickFormat)
                          }

                          xAxisSvgLocal
                              .transition().duration(500).ease("sin-in-out") // https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
                              .call(xAxisLocal);

                          var t0 = svgLocal.transition().duration(750);

                          //set the actual data to be used for the lines,
                          //and transition to the new data
                          line1SvgLocal
                              .datum(u1Data);
                          line2SvgLocal.datum(u2Data);

                          //redraw the lines with the previously assigned data

                          t0.selectAll(".line1").attr("d", lineLocal)
                              .attr("class", "line1");
                          t0.selectAll(".line2").attr("d", lineLocal)
                              .attr("class", "line2");


                          if (!isTotal) {
                              //metric is not a "total" metric
                              //label the lines, using the data value at the end of the line
                              line1TextLocal
                                  .datum(u1Data[u1Data.length - 1])
                                  .attr("class", "label")
                                  .attr("transform", function(d) {
                                      if (metric == "averageMilliseconds")
                                          return "translate(" + xLocal(+d[xdim]) + "," +
                                              yLocal((+d[totalMetric] / (factor))) + ")";
                                      if (d.totalMilliseconds == 0)
                                          return "translate(" + xLocal(+d[xdim]) + "," + yLocal(0) + ")";
                                      return "translate(" + xLocal(+d[xdim]) + "," +
                                          yLocal((+d[totalMetric] / (d.totalMilliseconds))) + ")";
                                  })
                                  .attr("x", 3)
                                  .attr("dy", ".35em")
                                  .text("User1");
                              line2TextLocal
                                  .datum(u2Data[u2Data.length - 1])
                                  .attr("class", "label")
                                  .attr("transform", function(d) {
                                      if (metric == "averageMilliseconds")
                                          return "translate(" + xLocal(+d[xdim]) + "," +
                                              yLocal((+d[totalMetric] / (factor))) + ")";
                                      if (d.totalMilliseconds == 0)
                                          return "translate(" + xLocal(+d[xdim]) + "," + yLocal(0) + ")";
                                      return "translate(" + xLocal(+d[xdim]) + "," +
                                          yLocal((+d[totalMetric] / (d.totalMilliseconds))) + ")";
                                  })
                                  .attr("x", 3)
                                  .attr("dy", "-.35em")
                                  .text("User2");

                          } else {
  							//total time chart

  							//label the lines, using the data value at the end of the line

                              line1TextLocal
                                  .datum(u1Data[u1Data.length - 1])
                                  .attr("class", "label")
                                  .attr("transform", function(d) {
                                      return "translate(" + xLocal(+d[xdim]) + "," +
                                          yLocal((+d[metric])) + ")";
                                  })
                                  .attr("x", 3)
                                  .attr("dy", ".35em")
                                  .text("User1");

                              line2TextLocal
                                  .datum(u2Data[u2Data.length - 1])
                                  .attr("class", "label")
                                  .attr("transform", function(d) {
                                  	console.log(xdim+","+metric);
                                  	console.log(d);
                                  	console.log("translate(" + xLocal(+d[xdim]) + "," +
                                          yLocal((+d[metric])) + ")");
                                      return "translate(" + xLocal(+d[xdim]) + "," +
                                          yLocal((+d[metric])) + ")";
                                  })
                                  .attr("x", 3)
                                  .attr("dy", "-.35em")
                                  .text("User2");
                          }
                          if (firstTime && !isTotal) {
                          	//draw the y-axis
                              yAxisSvgLocal.call(yAxisLocal);
                              firstTime = false;
                          } else {
                          	//draw the y-axis
                              yAxisSvgLocal.call(yAxisLocal);
                              var m = metrics[xdim];

                              //update the y-axis label, depending on the metrics used
                              var ylabel;
                              if (isTotal) ylabel = "Total Listening Time (milliseconds)";
                              else ylabel = metrics["hour"][0].ylabel;

                              m.forEach(function(d) {
                                  if (d.name == metric) ylabel = d.ylabel;
                              });
                              yAxisTextLocal.text(ylabel);
                          }

                      }

                  	//draw the total time chart
                      showChartForMetric("totalMilliseconds", "hour");

                  	//draw the metrics chart
                      showChartForMetric(metrics["hour"][0].name, "hour");

                  }); //User2 data
              }); //User1 data
          </script>
</body>

</html>
